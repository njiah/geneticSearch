# -*- coding: utf-8 -*-
"""Genetic_matchmaking.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hhT3-p11ijj8PiJCVImWfCZTky_W29f8
"""

import pandas as pd
import random
import heapq
from IPython.display import Markdown, display

possibilites = {}
possibilites['Sexuality'] = ['Heterosexual', 'Bisexual', 'Homosexual']
possibilites['MBTI'] = ['INTJ', 'INTP', 'ENTJ', 'ENTP', 'INFJ', 'INFP', 'ENFJ', 'ENFP', 'ISTJ', 'ISFJ', 'ESTJ', 'ESFJ', 'ISTP', 'ISFP', 'ESTP', 'ESFP']
possibilites['Hobbies'] = ['Photography', 'Gaming', 'Cooking/ Baking', 'Fitness', 'Arts and Crafts', 'Music', 'Reading', 'Writing', 'Gardening', 'Dancing', 'Travelling']
possibilites['Social Activities'] = ['Pub crawls', 'Club nights', 'Game nights', 'Potluck dinners', 'Outdoor activities', 'Workshops/ Skill-building events', 'Study groups', 'Sports tournaments', 'Karaoke nights', 'Food tasting']
possibilites['Looking For'] = ['A serious relationship', 'Casual dating to get to know someone', 'Making new friends']
possibilites['Energy Level'] = ['High-energy and adventurous', 'Balanced and adaptable', 'Laid-back and relax']
possibilites['Friday Night'] = ['Going out for a fun night with friends', 'Relaxing at home with a good movie or book', 'Exploring something new, like a restaurant or event', 'Working on personal projects or hobbies', 'Hitting the gym or doing something active', 'Attending a concert, show, or live performance', 'Drinking with friends at home or go clubbing']
possibilites['Favorite Beverage'] = ['Coffee', 'Tea', 'Cocktail','Wine', 'Beer',  'Smoothie/ juice']
possibilites['Sense of Humor'] = ['Quirky and random', 'Sarcastic and witty', 'Goofy and playful', 'Dry and subtle', 'Lighthearted and wholesome']

compatibility_matrix = {
    'INTJ': {'INTJ': 3, 'ENTP': 5, 'INFJ': 4, 'INTP': 4, 'ENTJ': 3, 'ENFP': 3, 'ISFP': 2, 'ISTP': 2, 'ESFP': 1, 'ESTP': 1, 'ESFJ': 2, 'ESTJ': 2, 'ISFJ': 3, 'ISTJ': 4, 'INFP': 3, 'ENFJ': 4},
    'ENTP': {'INTJ': 5, 'ENTP': 3, 'INFJ': 5, 'INTP': 4, 'ENTJ': 4, 'ENFP': 4, 'ISFP': 3, 'ISTP': 3, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 2, 'ESTJ': 2, 'ISFJ': 2, 'ISTJ': 3, 'INFP': 4, 'ENFJ': 5},
    'INFJ': {'INTJ': 4, 'ENTP': 5, 'INFJ': 3, 'INTP': 5, 'ENTJ': 4, 'ENFP': 5, 'ISFP': 4, 'ISTP': 3, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 4, 'ESTJ': 3, 'ISFJ': 5, 'ISTJ': 4, 'INFP': 5, 'ENFJ': 5},
    'INTP': {'INTJ': 4, 'ENTP': 4, 'INFJ': 5, 'INTP': 3, 'ENTJ': 4, 'ENFP': 4, 'ISFP': 3, 'ISTP': 4, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 2, 'ESTJ': 2, 'ISFJ': 3, 'ISTJ': 3, 'INFP': 4, 'ENFJ': 4},
    'ENTJ': {'INTJ': 3, 'ENTP': 4, 'INFJ': 4, 'INTP': 4, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 3, 'ISTP': 3, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 3, 'ESTJ': 4, 'ISFJ': 3, 'ISTJ': 4, 'INFP': 4, 'ENFJ': 5},
    'ENFP': {'INTJ': 3, 'ENTP': 4, 'INFJ': 5, 'INTP': 4, 'ENTJ': 4, 'ENFP': 3, 'ISFP': 4, 'ISTP': 3, 'ESFP': 4, 'ESTP': 4, 'ESFJ': 4, 'ESTJ': 3, 'ISFJ': 4, 'ISTJ': 3, 'INFP': 5, 'ENFJ': 5},
    'ISFP': {'INTJ': 2, 'ENTP': 3, 'INFJ': 4, 'INTP': 3, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 3, 'ISTP': 4, 'ESFP': 4, 'ESTP': 4, 'ESFJ': 4, 'ESTJ': 3, 'ISFJ': 4, 'ISTJ': 3, 'INFP': 4, 'ENFJ': 4},
    'ISTP': {'INTJ': 2, 'ENTP': 3, 'INFJ': 3, 'INTP': 4, 'ENTJ': 3, 'ENFP': 3, 'ISFP': 4, 'ISTP': 3, 'ESFP': 3, 'ESTP': 4, 'ESFJ': 3, 'ESTJ': 4, 'ISFJ': 3, 'ISTJ': 3, 'INFP': 3, 'ENFJ': 4},
    'ESFP': {'INTJ': 1, 'ENTP': 3, 'INFJ': 3, 'INTP': 3, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 4, 'ISTP': 3, 'ESFP': 3, 'ESTP': 4, 'ESFJ': 4, 'ESTJ': 4, 'ISFJ': 3, 'ISTJ': 2, 'INFP': 3, 'ENFJ': 4},
    'ESTP': {'INTJ': 1, 'ENTP': 3, 'INFJ': 3, 'INTP': 3, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 4, 'ISTP': 4, 'ESFP': 4, 'ESTP': 3, 'ESFJ': 3, 'ESTJ': 4, 'ISFJ': 3, 'ISTJ': 3, 'INFP': 3, 'ENFJ': 4},
    'ESFJ': {'INTJ': 2, 'ENTP': 2, 'INFJ': 4, 'INTP': 2, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 4, 'ISTP': 3, 'ESFP': 4, 'ESTP': 3, 'ESFJ': 3, 'ESTJ': 4, 'ISFJ': 5, 'ISTJ': 4, 'INFP': 4, 'ENFJ': 5},
    'ESTJ': {'INTJ': 2, 'ENTP': 2, 'INFJ': 3, 'INTP': 2, 'ENTJ': 4, 'ENFP': 3, 'ISFP': 3, 'ISTP': 4, 'ESFP': 4, 'ESTP': 4, 'ESFJ': 4, 'ESTJ': 3, 'ISFJ': 4, 'ISTJ': 5, 'INFP': 3, 'ENFJ': 4},
    'ISFJ': {'INTJ': 3, 'ENTP': 2, 'INFJ': 5, 'INTP': 3, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 4, 'ISTP': 3, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 5, 'ESTJ': 4, 'ISFJ': 3, 'ISTJ': 4, 'INFP': 5, 'ENFJ': 5},
    'ISTJ': {'INTJ': 4, 'ENTP': 3, 'INFJ': 4, 'INTP': 3, 'ENTJ': 4, 'ENFP': 3, 'ISFP': 3, 'ISTP': 3, 'ESFP': 2, 'ESTP': 3, 'ESFJ': 4, 'ESTJ': 5, 'ISFJ': 4, 'ISTJ': 3, 'INFP': 3, 'ENFJ': 4},
    'INFP': {'INTJ': 3, 'ENTP': 4, 'INFJ': 5, 'INTP': 4, 'ENTJ': 4, 'ENFP': 5, 'ISFP': 4, 'ISTP': 3, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 4, 'ESTJ': 3, 'ISFJ': 5, 'ISTJ': 3, 'INFP': 3, 'ENFJ': 5},
    'ENFJ': {'INTJ': 4, 'ENTP': 5, 'INFJ': 5, 'INTP': 4, 'ENTJ': 5, 'ENFP': 5, 'ISFP': 4, 'ISTP': 4, 'ESFP': 4, 'ESTP': 4, 'ESFJ': 5, 'ESTJ': 4, 'ISFJ': 5, 'ISTJ': 4, 'INFP': 5, 'ENFJ': 3}
}

def mbti_compatibility_score(mbti1, mbti2):
    compatibility_matrix = {
        'INTJ': {'INTJ': 3, 'ENTP': 5, 'INFJ': 4, 'INTP': 4, 'ENTJ': 3, 'ENFP': 3, 'ISFP': 2, 'ISTP': 2, 'ESFP': 1, 'ESTP': 1, 'ESFJ': 2, 'ESTJ': 2, 'ISFJ': 3, 'ISTJ': 4, 'INFP': 3, 'ENFJ': 4},
        'ENTP': {'INTJ': 5, 'ENTP': 3, 'INFJ': 5, 'INTP': 4, 'ENTJ': 4, 'ENFP': 4, 'ISFP': 3, 'ISTP': 3, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 2, 'ESTJ': 2, 'ISFJ': 2, 'ISTJ': 3, 'INFP': 4, 'ENFJ': 5},
        'INFJ': {'INTJ': 4, 'ENTP': 5, 'INFJ': 3, 'INTP': 5, 'ENTJ': 4, 'ENFP': 5, 'ISFP': 4, 'ISTP': 3, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 4, 'ESTJ': 3, 'ISFJ': 5, 'ISTJ': 4, 'INFP': 5, 'ENFJ': 5},
        'INTP': {'INTJ': 4, 'ENTP': 4, 'INFJ': 5, 'INTP': 3, 'ENTJ': 4, 'ENFP': 4, 'ISFP': 3, 'ISTP': 4, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 2, 'ESTJ': 2, 'ISFJ': 3, 'ISTJ': 3, 'INFP': 4, 'ENFJ': 4},
        'ENTJ': {'INTJ': 3, 'ENTP': 4, 'INFJ': 4, 'INTP': 4, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 3, 'ISTP': 3, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 3, 'ESTJ': 4, 'ISFJ': 3, 'ISTJ': 4, 'INFP': 4, 'ENFJ': 5},
        'ENFP': {'INTJ': 3, 'ENTP': 4, 'INFJ': 5, 'INTP': 4, 'ENTJ': 4, 'ENFP': 3, 'ISFP': 4, 'ISTP': 3, 'ESFP': 4, 'ESTP': 4, 'ESFJ': 4, 'ESTJ': 3, 'ISFJ': 4, 'ISTJ': 3, 'INFP': 5, 'ENFJ': 5},
        'ISFP': {'INTJ': 2, 'ENTP': 3, 'INFJ': 4, 'INTP': 3, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 3, 'ISTP': 4, 'ESFP': 4, 'ESTP': 4, 'ESFJ': 4, 'ESTJ': 3, 'ISFJ': 4, 'ISTJ': 3, 'INFP': 4, 'ENFJ': 4},
        'ISTP': {'INTJ': 2, 'ENTP': 3, 'INFJ': 3, 'INTP': 4, 'ENTJ': 3, 'ENFP': 3, 'ISFP': 4, 'ISTP': 3, 'ESFP': 3, 'ESTP': 4, 'ESFJ': 3, 'ESTJ': 4, 'ISFJ': 3, 'ISTJ': 3, 'INFP': 3, 'ENFJ': 4},
        'ESFP': {'INTJ': 1, 'ENTP': 3, 'INFJ': 3, 'INTP': 3, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 4, 'ISTP': 3, 'ESFP': 3, 'ESTP': 4, 'ESFJ': 4, 'ESTJ': 4, 'ISFJ': 3, 'ISTJ': 2, 'INFP': 3, 'ENFJ': 4},
        'ESTP': {'INTJ': 1, 'ENTP': 3, 'INFJ': 3, 'INTP': 3, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 4, 'ISTP': 4, 'ESFP': 4, 'ESTP': 3, 'ESFJ': 3, 'ESTJ': 4, 'ISFJ': 3, 'ISTJ': 3, 'INFP': 3, 'ENFJ': 4},
        'ESFJ': {'INTJ': 2, 'ENTP': 2, 'INFJ': 4, 'INTP': 2, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 4, 'ISTP': 3, 'ESFP': 4, 'ESTP': 3, 'ESFJ': 3, 'ESTJ': 4, 'ISFJ': 5, 'ISTJ': 4, 'INFP': 4, 'ENFJ': 5},
        'ESTJ': {'INTJ': 2, 'ENTP': 2, 'INFJ': 3, 'INTP': 2, 'ENTJ': 4, 'ENFP': 3, 'ISFP': 3, 'ISTP': 4, 'ESFP': 4, 'ESTP': 4, 'ESFJ': 4, 'ESTJ': 3, 'ISFJ': 4, 'ISTJ': 5, 'INFP': 3, 'ENFJ': 4},
        'ISFJ': {'INTJ': 3, 'ENTP': 2, 'INFJ': 5, 'INTP': 3, 'ENTJ': 3, 'ENFP': 4, 'ISFP': 4, 'ISTP': 3, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 5, 'ESTJ': 4, 'ISFJ': 3, 'ISTJ': 4, 'INFP': 5, 'ENFJ': 5},
        'ISTJ': {'INTJ': 4, 'ENTP': 3, 'INFJ': 4, 'INTP': 3, 'ENTJ': 4, 'ENFP': 3, 'ISFP': 3, 'ISTP': 3, 'ESFP': 2, 'ESTP': 3, 'ESFJ': 4, 'ESTJ': 5, 'ISFJ': 4, 'ISTJ': 3, 'INFP': 3, 'ENFJ': 4},
        'INFP': {'INTJ': 3, 'ENTP': 4, 'INFJ': 5, 'INTP': 4, 'ENTJ': 4, 'ENFP': 5, 'ISFP': 4, 'ISTP': 3, 'ESFP': 3, 'ESTP': 3, 'ESFJ': 4, 'ESTJ': 3, 'ISFJ': 5, 'ISTJ': 3, 'INFP': 3, 'ENFJ': 5},
        'ENFJ': {'INTJ': 4, 'ENTP': 5, 'INFJ': 5, 'INTP': 4, 'ENTJ': 5, 'ENFP': 5, 'ISFP': 4, 'ISTP': 4, 'ESFP': 4, 'ESTP': 4, 'ESFJ': 5, 'ESTJ': 4, 'ISFJ': 5, 'ISTJ': 4, 'INFP': 5, 'ENFJ': 3}
    }
    return compatibility_matrix.get(mbti1, {}).get(mbti2, 0)

def calculate_score(participant1, participant2):
    score = 0

    # Gender and sexuality matching
    if participant1['Sexuality'] == 'Homosexual':
        if participant1['Gender'] != participant2['Gender']:
            return 0
    elif participant1['Sexuality'] == 'Heterosexual':
        if participant1['Gender'] == participant2['Gender']:
            return 0
    elif participant1['Sexuality'] == 'Bisexual':
        pass  # Bisexual can match with anyone
    else:
        return 0  # Invalid sexuality case

    # Check if the second participant's sexuality is compatible with the first
    if participant2['Sexuality'] == 'Homosexual':
        if participant2['Gender'] != participant1['Gender']:
            return 0
    elif participant2['Sexuality'] == 'Heterosexual':
        if participant2['Gender'] == participant1['Gender']:
            return 0
    elif participant2['Sexuality'] == 'Bisexual':
        pass  # Bisexual can match with anyone

    # If gender and sexuality align, calculate compatibility
    # Check MBTI compatibility (scaled 0 to 5 points)
    score += mbti_compatibility_score(participant1['MBTI'], participant2['MBTI'])

    # Check hobbies (1 point per match, max 3 points)
    hobbies1 = set(participant1['Hobbies'].split(", "))
    hobbies2 = set(participant2['Hobbies'].split(", "))
    shared_hobbies = hobbies1.intersection(hobbies2)
    score += min(3, len(shared_hobbies))

    # Check social activities (1 point per match, max 3 points)
    activities1 = set(participant1['Social Activities'].split(", "))
    activities2 = set(participant2['Social Activities'].split(", "))
    shared_activities = activities1.intersection(activities2)
    score += min(3, len(shared_activities))

    # Check what they are looking for (3 points)
    if participant1['Looking For'] == participant2['Looking For']:
        score += 3

    # Check preferred energy level (3 points)
    if participant1['Energy Level'] == participant2['Energy Level']:
        score += 3

    # Fun compatibility questions (1 point each)
    if participant1['Friday Night'] == participant2['Friday Night']:
        score += 1
    if participant1['Favorite Beverage'] == participant2['Favorite Beverage']:
        score += 1
    if participant1['Sense of Humor'] == participant2['Sense of Humor']:
        score += 1

    return score

def get_best_mbti(matrix):
    x = [key for key, value in matrix.items() if value == max(matrix.values())]
    return random.choice(x)

class GA:
    def __init__(self):
        self.population = []
        self.fitness = []
        self.population_size = 10
        self.generations = 5
        self.mutation_rate = 0.9
        self.crossover_rate = 0.2
        self.posibilities = possibilites
        self.compatibility_matrix = compatibility_matrix

    def create_initial_population(self):
        for i in range(self.population_size):
            person1 = {}
            person2 = {}
            for key, value in possibilites.items():
                if key == 'Hobbies' or key == 'Social Activities' or key == 'Friday Night' or key == 'Favorite Beverage':
                    person1[key] = random.sample(value, random.randint(1, len(value)))
                    person1[key] = ', '.join(person1[key])
                    person2[key] = random.sample(value, random.randint(1, len(value)))
                    person2[key] = ', '.join(person2[key])
                else:
                    person1[key] = value[random.randint(0, len(value)-1)]
                    person2[key] = value[random.randint(0, len(value)-1)]
                    person1['Gender'] = random.choice(["female", "male"])
                    person2['Gender'] = random.choice(["female", "male"])
            gene_pair = (person1, person2)
            self.population.append(gene_pair)
        return self.population

    def calculate_fitness(self):
        self.fitness = []
        for pair in self.population:
            score = calculate_score(pair[0], pair[1])
            self.fitness.append(score)
        return self.fitness

    def selection(self, generation=1):
        best_pairs_indices = heapq.nlargest(2, range(len(self.fitness)), key=self.fitness.__getitem__)
        print(f"Best scores in generation {generation}: {[self.fitness[i] for i in best_pairs_indices]} ")
        best_pairs = [self.population[i] for i in best_pairs_indices]
        return best_pairs

    def crossover(self, pair1, pair2):
        if random.random() > self.crossover_rate:
            return pair1, pair2
        else:
            child1 = (pair1[0], pair2[1])
            child2 = (pair2[0], pair1[1])
            return child1, child2

    def new_generation(self, pair1, pair2):
        new_population = []
        new_population.append(pair1)
        new_population.append(pair2)
        for i in range(self.population_size-2):
            child1, child2 = self.crossover(pair1, pair2)
            new_population.append(child1)
            new_population.append(child2)
        return new_population

    def mutation(self, new_population):
        for pair in new_population:

            if random.random() < self.mutation_rate:
                pair[1]["MBTI"] = get_best_mbti(compatibility_matrix[pair[0]["MBTI"]])

            chosen = random.choice([0, 1])
            if random.random() < self.mutation_rate:
                pair[chosen]["Hobbies"] = pair[chosen]["Hobbies"].split(", ")
                while len(pair[chosen]["Hobbies"]) < len(self.posibilities["Hobbies"]):
                    hobby = random.choice(self.posibilities["Hobbies"])
                    if hobby not in pair[chosen]["Hobbies"]:
                        pair[chosen]["Hobbies"].append(hobby)
                pair[chosen]["Hobbies"] = ', '.join(pair[chosen]["Hobbies"])

            if random.random() < self.mutation_rate:
                pair[chosen]["Social Activities"] = pair[chosen]["Social Activities"].split(", ")
                while len(pair[chosen]["Social Activities"]) < len(self.posibilities["Social Activities"]):
                    activity = random.choice(self.posibilities["Social Activities"])
                    if activity not in pair[chosen]["Social Activities"]:
                        pair[chosen]["Social Activities"].append(activity)
                pair[chosen]["Social Activities"] = ', '.join(pair[chosen]["Social Activities"])

            if random.random() < self.mutation_rate:
                pair[0]["Looking For"] = pair[1]["Looking For"]

            if random.random() < self.mutation_rate:
                pair[0]["Energy Level"] = pair[1]["Energy Level"]

            if random.random() < self.mutation_rate:
                pair[1]["Friday Night"] = pair[0]["Friday Night"]

            if random.random() < self.mutation_rate:
                pair[1]["Favorite Beverage"] = pair[0]["Favorite Beverage"]

            if random.random() < self.mutation_rate:
                pair[0]["Sense of Humor"] = pair[1]["Sense of Humor"]

        return new_population

    def run(self):
        self.create_initial_population()
        best_score = 0
        best_pair = None
        best_score_this_gen = 0
        for gen in range(self.generations):
            self.calculate_fitness()

            best_pairs = self.selection(generation=gen)

            best_score_this_gen = max(self.fitness)
            if best_score_this_gen > best_score:
                best_score = best_score_this_gen
                self.mutation_rate -= 0.1
                best_pair = self.population[self.fitness.index(best_score_this_gen)]

            if len(best_pairs) < 2:
                self.create_initial_population()
            else:
                new_pop = self.new_generation(best_pairs[0], best_pairs[1])
                new_pop = self.mutation(new_pop)

            '''best_score_this_gen = max(self.fitness)
            if best_score_this_gen > best_score:
                best_score = best_score_this_gen
                self.mutation_rate -= 0.1
            best_pair = self.population[self.fitness.index(best_score)]'''

            self.population = new_pop
            self.fitness = []

        print(f"Best score: {best_score}")
        print(f"Best pair: {best_pair}")

        self.new_generation(best_pairs[0], best_pairs[1])

        return best_score, best_pair

ga = GA()
best_score, best_pair = ga.run()